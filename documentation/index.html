<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>
      MapStruct - Java Bean Mappings, the Easy Way!
    </title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <style>
      body {
        padding-top: 60px;
      }
    </style>
    <script src="http://mapstruct.org/javascripts/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="http://mapstruct.org/javascripts/bootstrap-tab.js" type="text/javascript"></script>
    <script src="http://mapstruct.org/javascripts/bootstrap-scrollspy.js" type="text/javascript"></script>
    <script src="http://mapstruct.org/javascripts/bootstrap-affix.js" type="text/javascript"></script>
    <link href="http://mapstruct.org/stylesheets/styles.css" rel="stylesheet" type="text/css">
    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
    <link href="http://mapstruct.org/stylesheets/gh-fork-ribbon.css" rel="stylesheet" type="text/css">
    <!--[if IE]>
      <link href="http://mapstruct.org/stylesheets/gh-fork-ribbon.ie.css" rel="stylesheet" type="text/css">
    <![endif]-->
    <link href="http://mapstruct.org/stylesheets/prettify.css" rel="stylesheet" type="text/css">
    <script src="http://mapstruct.org/javascripts/prettify.js" type="text/javascript"></script>
    <script>
      (function(jQuery){
        jQuery( document ).ready( function() {
          prettyPrint();
        } );
      }(jQuery))
    </script>
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="hidden-phone pull-right" style="padding-top: 11px; margin-right: 120px;">
        <div class="g-plusone" data-size="medium"></div>
        <script>
          (function() {
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
            po.src = 'https://apis.google.com/js/plusone.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
          })();
        </script>
      </div>
      <div class="hidden-phone github-fork-ribbon-wrapper right">
        <div class="github-fork-ribbon">
          <a href="https://github.com/mapstruct/mapstruct">Fork me on GitHub</a>
        </div>
      </div>
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">MapStruct</a>
          <ul class="nav">
            <li>
              <a href="/">Home</a>
            </li>
            <li>
              <a href="http://mapstruct.org/news">News</a>
            </li>
            <li>
              <a href="http://mapstruct.org/documentation">Documentation</a>
            </li>
            <li>
              <a href="http://mapstruct.org/download">Download</a>
            </li>
            <li>
              <a href="http://mapstruct.org/getting-help">Getting help</a>
            </li>
            <li>
              <a href="http://mapstruct.org/contributing">Contributing</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="container">
      <div class="row">
        <div class="span12">
          <h2>MapStruct User Guide</h2>
        </div>
      </div>
      <div class="row">
        <div class="span9">
          <div class="row">
            <div class="span9">
              <p>This is the MapStruct reference documentation which covers all functionality provided by MapStruct. In case this guide doesn't answer all your questions just join the MapStruct <a href="https://groups.google.com/forum/?fromgroups#!forum/mapstruct-users">Google group</a> to get help.</p>
              
              <p>You found a typo or other error in this guide? Your pull request against this web site's <a href="http://github.com/mapstruct/mapstruct.org">GitHub repository</a> is more than welcome!</p>
            </div>
          </div>
          <div class="row">
            <div class="span9">
              <h3 id="section-01">1. Introduction</h3>
              <p>MapStruct is a Java <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/apt/index.html">annotation processor</a> for the generation of type-safe bean mapping classes.</p>
              
              <p>All you have to do is to define a mapper interface which declares any required mapping methods. During compilation, MapStruct will generate an implementation of this interface. This implementation uses plain Java method invocations for mapping between source and target objects, i.e. no reflection or similar.</p>
              
              <p>Compared to writing mapping code from hand, MapStruct saves time by generating code which is tedious and error-prone to write. Following a convention over configuration approach, MapStruct uses sensible defaults but steps out of your way when it comes to configuring or implementing special behavior.</p>
              
              <p>Compared to dynamic mapping frameworks, MapStruct offers the following advantages:</p>
              
              <ul>
                <li>Fast execution by using plain method invocations instead of reflection</li>
                <li>Compile-time type safety: Only objects and attributes mapping to each other can be mapped, no accidental mapping of an order entity into a customer DTO etc.</li>
                <li>Clear error-reports at build time, if entities or attributes can't be mapped</li>
              </ul>
            </div>
          </div>
          <div class="row">
            <div class="span9">
              <h3 id="section-02">2. Set up</h3>
              <p>MapStruct is a Java annotation processor based on <a href="jcp.org/en/jsr/detail?id=269">JSR 269</a> and as such can be used within command line builds (javac, Ant, Maven etc.) as well as from within your IDE.</p>
              
              <p>It comprises two artifacts:</p>
              
              <ul>
                <li><em>org.mapstruct:mapstruct</em>: contains the required annotations such as <code>@Mapping</code></li>
                <li><em>org.mapstruct:mapstruct-processor</em>: contains the annotation processor which generates mapper implementations</li>
              </ul>
              
              <p>For Maven based projects add the following to your POM file in order to use MapStruct:</p>
              <pre class="prettyprint lang-xml linenums">...&#x000A;&lt;properties&gt;&#x000A;    &lt;org.mapstruct.version&gt;1.0.0.Alpha2&lt;/org.mapstruct.version&gt;&#x000A;&lt;/properties&gt;&#x000A;...&#x000A;&lt;dependencies&gt;&#x000A;    &lt;dependency&gt;&#x000A;        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#x000A;        &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;&#x000A;        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;&#x000A;    &lt;/dependency&gt;&#x000A;&lt;/dependencies&gt;&#x000A;...&#x000A;&lt;build&gt;&#x000A;    &lt;plugins&gt;&#x000A;        &lt;plugin&gt;&#x000A;            &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt;&#x000A;            &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt;&#x000A;            &lt;version&gt;2.2.4&lt;/version&gt;&#x000A;            &lt;configuration&gt;&#x000A;                &lt;defaultOutputDirectory&gt;&#x000A;                    ${project.build.directory}/generated-sources&#x000A;                &lt;/defaultOutputDirectory&gt;&#x000A;                &lt;processors&gt;&#x000A;                    &lt;processor&gt;org.mapstruct.ap.MappingProcessor&lt;/processor&gt;&#x000A;                &lt;/processors&gt;&#x000A;            &lt;/configuration&gt;&#x000A;            &lt;executions&gt;&#x000A;                &lt;execution&gt;&#x000A;                    &lt;id&gt;process&lt;/id&gt;&#x000A;                    &lt;phase&gt;generate-sources&lt;/phase&gt;&#x000A;                    &lt;goals&gt;&#x000A;                        &lt;goal&gt;process&lt;/goal&gt;&#x000A;                    &lt;/goals&gt;&#x000A;                &lt;/execution&gt;&#x000A;            &lt;/executions&gt;&#x000A;            &lt;dependencies&gt;&#x000A;                &lt;dependency&gt;&#x000A;                    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;&#x000A;                    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;&#x000A;                    &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;&#x000A;                &lt;/dependency&gt;&#x000A;            &lt;/dependencies&gt;&#x000A;        &lt;/plugin&gt;&#x000A;    &lt;/plugins&gt;&#x000A;&lt;/build&gt;</pre>
              <h4 id="section-02-01">2.1 Configuration options</h4>
              <p>The MapStruct code generator can be configured using <em>annotation processor options</em>.</p>
              
              <p>When invoking javac directly, these options are passed to the compiler in the form <em>-Akey=value</em>. When using MapStruct via Maven, any processor options can be passed using an <code>options</code> element within the configuration of the Maven processor plug-in like this:</p>
              <pre class="prettyprint lang-xml linenums">...&#x000A;&lt;plugin&gt;&#x000A;    &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt;&#x000A;    &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt;&#x000A;    &lt;configuration&gt;&#x000A;        &lt;processors&gt;&#x000A;            &lt;processor&gt;org.mapstruct.ap.MappingProcessor&lt;/processor&gt;&#x000A;        &lt;/processors&gt;&#x000A;        &lt;options&gt;&#x000A;            &lt;suppressGeneratorTimestamp&gt;true&lt;/suppressGeneratorTimestamp&gt;&#x000A;            &lt;defaultComponentModel&gt;cdi&lt;/defaultComponentModel&gt;&#x000A;        &lt;/options&gt;&#x000A;        ...&#x000A;    &lt;/configuration&gt;&#x000A;    ...&#x000A;&lt;plugin&gt;&#x000A;...</pre>
              <p>The following options exist:</p>
              <table class="table">
                <thead>
                  <tr>
                    <th>Option</th>
                    <th>Purpose</th>
                    <th>Default</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>suppressGeneratorTimestamp</td>
                    <td>Whether the creation of a time stamp in the generated mapper classes is suppressed or not</td>
                    <td>
                      <p><code>false</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>defaultComponentModel</td>
                    <td>
                      <p>The name of the component model (see <a href="#section-04-2">section 4.2</a>) based on which mappers should be generated. Supported values are:</p>
                      <ul>
                        <li>
                          <p><code>default</code>: the mapper uses no component model, instances are typically retrieved via <code>Mappers#getMapper(Class)</code></p>
                        </li>
                        <li>
                          <p><code>cdi</code>: the generated mapper is an application-scoped CDI bean and can be retrieved via <code>@Inject</code></p>
                        </li>
                        <li>
                          <p><code>spring</code>: the generated mapper is a singleton-scoped Spring bean and can be retrieved via <code>@Autowired</code></p>
                        </li>
                        <li>
                          <p><code>jsr330</code>: the generated mapper is annotated with {@code @Named} and can be retrieved via <code>@Inject</code>, e.g. using Spring</p>
                        </li>
                      </ul>
                      <p>If a component model is given for a specific mapper via <code>@Mapper#componentModel()</code>, the value from the annotation takes precedence.</p>
                    </td>
                    <td>
                      <p><code>default</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>unmappedTargetPolicy</td>
                    <td>
                      <p>The default reporting policy to be applied in case an attribute of the target object of a mapping method is not populated with a source value.
                      Supported values are:</p>
                      <ul>
                        <li>
                          <p><code>ERROR</code>: any unmapped target property will cause the mapping code generation to fail</p>
                        </li>
                        <li>
                          <p><code>WARN</code>: any unmapped target property will cause a warning at build time</p>
                        </li>
                        <li>
                          <p><code>IGNORE</code>: unmapped target properties are ignored</p>
                        </li>
                      </ul>
                      <p>If a policy is given for a specific mapper via <code>@Mapper#unmappedTargetPolicy()</code>, the value from the annotation takes precedence.</p>
                    </td>
                    <td>
                      <p><code>WARN</code></p>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="row">
            <div class="span9">
              <h3 id="section-03">3. Defining a mapper</h3>
              <p>In this section you'll learn how to define a bean mapper with MapStruct and which options you have to do so.</p>
              <h4 id="section-03-01">3.1 Basic mappings</h4>
              <p>To create a mapper simply define a Java interface with the required mapping method(s) and annotate it with the <code>org.mapstruct.Mapper</code> annotation:</p>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface CarMapper {&#x000A;&#x000A;    @Mappings({&#x000A;        @Mapping(source = &quot;make&quot;, target = &quot;manufacturer&quot;),&#x000A;        @Mapping(source = &quot;numberOfSeats&quot;, target = &quot;seatCount&quot;)&#x000A;    })&#x000A;    CarDto carToCarDto(Car car);&#x000A;&#x000A;    @Mapping(source = &quot;name&quot;, target = &quot;fullName&quot;)&#x000A;    PersonDto personToPersonDto(Person person);&#x000A;}</pre>
              <p>The <code>@Mapper</code> annotation causes the MapStruct code generator to create an implementation of the <code>CarMapper</code> interface during build-time.</p>
              
              <p>In the generated method implementations all readable properties from the source type (e.g. <code>Car</code>) will be copied ino the corresponding property in the target type (e.g. <code>CarDto</code>). If a property has a different name in the target entity, its name can be specified via the <code>@Mapping</code> annotation.</p>
              <div class="alert alert-info">
                <p><strong>Tip!</strong> The property name as defined in the <a href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">JavaBeans spefication</a> must be specified in the <code>@Mapping</code> annotation, e.g. <em>seatCount</em> for a property with the accessor methods <code>getSeatCount()</code> and <code>setSeatCount()</code>.</p>
              </div>
              <p>To get a better understanding of what MapStruct does have a look at the following implementation of the <code>carToCarDto()</code> method as generated by MapStruct:</p>
              <pre class="prettyprint lang-java linenums">// GENERATED CODE&#x000A;public class CarMapperImpl implements CarMapper {&#x000A;&#x000A;    @Override&#x000A;    public CarDto carToCarDto(Car car) {&#x000A;        if ( car == null ) {&#x000A;            return null;&#x000A;        }&#x000A;&#x000A;        CarDto carDto = new CarDto();&#x000A;&#x000A;        if ( car.getFeatures() != null ) {&#x000A;            carDto.setFeatures( new ArrayList&lt;String&gt;( car.getFeatures() ) );&#x000A;        }&#x000A;        carDto.setManufacturer( car.getMake() );&#x000A;        carDto.setSeatCount( car.getNumberOfSeats() );&#x000A;        carDto.setDriver( personToPersonDto( car.getDriver() ) );&#x000A;        carDto.setPrice( String.valueOf( car.getPrice() ) );&#x000A;        if ( car.getCategory() != null ) {&#x000A;            carDto.setCategory( car.getCategory().toString() );&#x000A;        }&#x000A;&#x000A;        return carDto;&#x000A;    }&#x000A;&#x000A;    //Other methods...&#x000A;}</pre>
              <p>The general philosophy of MapStruct is to generate code which looks as much as possible as if you had written it yourself from hand. In particular this means that the values are copied from source to target by plain getter/setter invocations instead of reflection or similar.</p>
              
              <p>As the example shows the generated code takes into account any name mappings specified via <code>@Mapping</code>. If the type of a mapped attribute is different in source and target entity, MapStruct will either apply an automatic conversion (as e.g. for the <em>price</em> property, see also <a href="#section-05-01">Implicit type conversions</a>) or optionally invoke another mapping method (as e.g. for the <em>driver</em> property, see also <a href="#section-05-02">Mapping object references</a>).</p>
              
              <p>Collection-typed attributes with the same element type will be copied by creating a new instance of the target collection type containing the elements from the source property. For collection-typed attributes with different element types each element will mapped individually and added to the target collection (see <a href="#section-06">Mapping collections</a>).</p>
              
              <p>MapStruct takes all public properties of the source and target types into account. This includes properties declared on super-types.</p>
              <h4 id="section-03-02">3.2 Mapping methods with several source parameters</h4>
              <p>MapStruct also supports mapping methods with several source parameters. This is useful e.g. in order to combine several entities into one data transfer object. The following shows an example:</p>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface AddressMapper {&#x000A;&#x000A;    @Mappings({&#x000A;        @Mapping(source = &quot;person.description&quot;, target = &quot;description&quot;),&#x000A;        @Mapping(source = &quot;houseNo&quot;, target = &quot;houseNumber&quot;)&#x000A;    })&#x000A;    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);&#x000A;}</pre>
              <p>The shown mapping method takes two source parameters and returns a combined target object. As with single-parameter mapping methods properties are mapped by name.</p>
              
              <p>In case several source objects define a property with the same name, the source parameter from which to retrieve the property must be specified using the <code>@Mapping</code> annotation as shown for the <code>description</code> property in the example. An error will be raised when such an ambiguity is not resolved. For properties which only exist once in the given source objects it is optional to specify the source parameter's name as it can be determined automatically.</p>
              <div class="alert alert-info">
                <p><strong>Tip!</strong> Mapping methods with several source parameters will return <code>null</code> in case all the source parameters are <code>null</code>. Otherwise the target object will be instantiated and all properties from the provided parameters will be propagated.</p>
              </div>
              <h4 id="section-03-03">3.3 Updating existing bean instances</h4>
              <p>In some cases you need mappings which don't create a new instance of the target type but instead update an existing instance of that type. This sort of mapping can be realized by adding a parameter for the target object and marking this parameter with <code>@MappingTarget</code>. The following shows an example:</p>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface CarMapper {&#x000A;&#x000A;    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);&#x000A;}</pre>
              <p>The generated code of the <code>updateCarFromDto</code> will upate the passed <code>Car</code> instance with the properties from the given <code>CarDto</code> object. There may be only one parameter marked as mapping target. Instead of <code>void</code> you also set the method's return type to the type of the target parameter, which will cause the generated implementation to update the passed mapping target and return it as well.</p>
            </div>
          </div>
          <div class="row">
            <div class="span9">
              <h3 id="section-04">4. Retrieving a mapper</h3>
              <h4 id="section-04-01">4.1 The Mappers factory</h4>
              <p>Mapper instances can be retrieved via the <code>org.mapstruct.factory.Mappers</code> class. Just invoke the <code>getMapper()</code> method, passing the interface type of the mapper to return:</p>
              <pre class="prettyprint lang-java linenums">CarMapper mapper = Mappers.getMapper( CarMapper.class );</pre>
              <p>By convention, a mapper interface should define a member called <code>INSTANCE</code> which holds a single instance of the mapper type:</p>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface CarMapper {&#x000A;&#x000A;    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );&#x000A;&#x000A;    CarDto carToCarDto(Car car);&#x000A;}</pre>
              <p>This pattern makes it very easy for clients to use mapper objects without repeatedly instantiating new instances:</p>
              <pre class="prettyprint lang-java linenums">Car car = ...;&#x000A;CarDto dto = CarMapper.INSTANCE.carToCarDto( car );</pre>
              <p>Note that mappers generated by MapStruct are thread-safe and thus can safely be accessed from several threads at the same time.</p>
              <h4 id="section-04-02">4.2 Using dependency injection</h4>
              <p>If you're working with a dependency injection framework such as <a href="http://jcp.org/en/jsr/detail?id=346">CDI</a> (Contexts and Dependency Injection for Java<sup>TM</sup> EE) or the <a href="http://www.springsource.org/spring-framework">Spring Framework</a>, it is recommended to obtain mapper objects via dependency injection as well. For that purpose you can specify the component model which generated mapper classes should be based on either via <code>@Mapper#componentModel</code> or using a processor option as described in <a href="section-02-01">section</a>.</p>
              
              <p>Currently there is support for CDI and Spring (the later either via its custom annotations or using the JSR 330 annotations). See <a href="section-02-01">section</a> for the allowed values of the <code>componentModel</code> attribute which are the same as for the <code>defaultComponentModel</code> processor option. In both cases the required annotations will be added to the generated mapper implementations classes in order to make the same subject to dependency injection. The following shows an example using CDI:</p>
              <pre class="prettyprint lang-java linenums">@Mapper(componentModel = &quot;cdi&quot;)&#x000A;public interface CarMapper {&#x000A;&#x000A;    CarDto carToCarDto(Car car);&#x000A;}</pre>
              <p>The generated mapper implementation will be marked with the <code>@ApplicationScoped</code> annotation and thus can be injected into fields, constructor arguments etc. using the <code>@Inject</code> annotation:</p>
              <pre class="prettyprint lang-java linenums">@Inject&#x000A;private CarMapper mapper;</pre>
              <p>A mapper which uses other mapper classes (see <a href="section-05-03">section</a>) will obtain these mappers using the configured component model. So if <code>CarMapper</code> from the previous example was using another mapper, this other mapper would have to be an injectable CDI bean as well.</p>
            </div>
          </div>
          <div class="row">
            <div class="span9">
              <h3 id="section-05">5. Data type conversions</h3>
              <p>Not always a mapped attribute has the same type in the source and target objects. For instance an attribute may be of type <code>int</code> in the source bean but of type <code>Long</code> in the target bean.</p>
              
              <p>Another example are references to other objects which should be mapped to the corresponding types in the target model. E.g. the class <code>Car</code> might have a property <code>driver</code> of the type <code>Person</code> which needs to be converted into a <code>PersonDto</code> object when mapping a <code>Car</code> object.</p>
              
              <p>In this section you'll learn how MapStruct deals with such data type conversions.</p>
              <h4 id="section-05-01">5.1 Implicit type conversions</h4>
              <p>MapStruct takes care of type conversions automatically in many cases. If for instance an attribute is of type <code>int</code> in the source bean but of type <code>String</code> in the target bean, the generated code will transparently perform a conversion by calling <code>String#valueOf(int)</code> and <code>Integer#parseInt(String)</code>, respectively.</p>
              
              <p>Currently the following conversions are applied automatically:</p>
              
              <ul>
                <li>
                  <p>Between all Java primitive data types and their corresponding wrapper types, e.g. between <code>int</code> and <code>Integer</code>, <code>boolean</code> and <code>Boolean</code> etc. The generated code is <code>null</code> aware, i.e. when converting a wrapper type into the corresponding primitive type a <code>null</code> check will performed.</p>
                </li>
                <li>
                  <p>Between all Java primitive number types and the wrapper types, e.g. between <code>int</code> and <code>long</code> or <code>byte</code> and <code>Integer</code>.</p>
                </li>
              </ul>
              <div class="alert alert-warn">
                <p><strong>Note!</strong> Converting from larger data types to smaller ones (e.g. from <code>long</code> to <code>int</code>) can cause a value or precision loss. There <a href="https://github.com/mapstruct/mapstruct/issues/5">will be</a> an option for raising a warning in such cases in a future MapStruct version.</p>
              </div>
              <ul>
                <li>
                  <p>Between all Java primitive types (including their wrappers) and <code>String</code>, e.g. between <code>int</code> and <code>String</code> or <code>Boolean</code> and <code>String</code>.</p>
                </li>
                <li>
                  <p>Between <code>enum</code> types and <code>String</code>.</p>
                </li>
                <li>
                  <p>Between big number types (<code>java.math.BigInteger</code>, <code>java.math.BigDecimal</code>) and Java primitive types (including their wrappers) as well as String</p>
                </li>
                <li>
                  <p>Between <code>java.util.Date</code> and <code>String</code>. A format string as understood by <code>java.text.SimpleDateFormat</code> can be specified via the <code>dateFormat</code> option as this:</p>
                </li>
              </ul>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface CarMapper {&#x000A;&#x000A;  @Mapping(source = &quot;manufacturingDate&quot;, dateFormat = &quot;dd.MM.yyyy&quot;)&#x000A;  CarDto carToCarDto(Car car);&#x000A;&#x000A;  @IterableMapping(dateFormat = &quot;dd.MM.yyyy&quot;)&#x000A;  List&lt;String&gt; stringListToDateList(List&lt;Date&gt; dates);&#x000A;}</pre>
              <h4 id="section-05-02">5.2 Mapping object references</h4>
              <p>Typically an object has not only primitive attributes but also references other objects. E.g. the <code>Car</code> class could contain a reference to a <code>Person</code> object (representing the car's driver) which should be mapped to a <code>PersonDto</code> object referenced by the <code>CarDto</code> class.</p>
              
              <p>In this case just define a mapping method for the referenced object type as well:</p>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface CarMapper {&#x000A;&#x000A;    CarDto carToCarDto(Car car);&#x000A;&#x000A;    PersonDto personToPersonDto(Person person);&#x000A;}</pre>
              <p>The generated code for the <code>carToCarDto()</code> method will invoke the <code>personToPersonDto()</code> method for mapping the <code>driver</code> attribute, while the generated implementation for <code>personToPersonDto()</code> performs the mapping of person objects.</p>
              
              <p>That way it is possible to map arbitrary deep object graphs. When mapping from entities into data transfer objects it is often useful to cut references to other entities at a certain point. To do so, implement a custom mapping method (see the next section) which e.g. maps a referenced entity to its id in the target object.</p>
              <p>When generating the implementation of a mapping method, MapStruct will apply the following routine for each attribute pair in the source and target object:</p>
              
              <ul>
                <li>If source and target attribute have the same type, the value will be simply copied from source to target. If the attribute is a collection (e.g. a <code>List</code>) a copy of the collection will be set into the target attribute.</li>
                <li>If source and target attribute type differ, check whether there is a another mapping method which has the type of the source attribute as parameter type and the type of the target attribute as return type. If such a method exists it will be invoked in the generated mapping implementation.</li>
                <li>If no such method exists MapStruct will look whether a built-in conversion for the source and target type of the attribute exists. If this is the case, the generated mapping code will apply this conversion.</li>
                <li>Otherwise an error will be raised at build time, indicating the non-mappable attribute.</li>
              </ul>
              <h4 id="section-05-03">5.3 Invoking other mappers</h4>
              <p>In addition to methods defined on the same mapper type MapStruct can also invoke mapping methods defined in other classes, be it mappers generated by MapStruct or hand-written mapping methods. This can be useful to structure your mapping code in several classes (e.g. with on mapper type per application module) or you want to provide custom mapping logic which can't be generated by MapStruct.</p>
              
              <p>For instance the <code>Car</code> class might contain an attribute <code>manufacturingDate</code> while the corresponding DTO attribute is of type String. In order to map this attribute, you could implement a mapper class like this:</p>
              <pre class="prettyprint lang-java linenums">public class DateMapper {&#x000A;&#x000A;    public String asString(Date date) {&#x000A;        return date != null ? new SimpleDateFormat( &quot;yyyy-MM-dd&quot; )&#x000A;            .format( date ) : null;&#x000A;    }&#x000A;&#x000A;    public Date asDate(String date) {&#x000A;        try {&#x000A;            return date != null ? new SimpleDateFormat( &quot;yyyy-MM-dd&quot; )&#x000A;                .parse( date ) : null;&#x000A;        }&#x000A;        catch ( ParseException e ) {&#x000A;            throw new RuntimeException( e );&#x000A;        }&#x000A;    }&#x000A;}</pre>
              <p>In the <code>@Mapper</code> annotation at the <code>CarMapper</code> interface reference the <code>DateMapper</code> class like this:</p>
              <pre class="prettyprint lang-java linenums">@Mapper(uses=DateMapper.class)&#x000A;public class CarMapper {&#x000A;&#x000A;    CarDto carToCarDto(Car car);&#x000A;}</pre>
              <p>When generating code for the implementation of the <code>carToCarDto()</code> method, MapStruct will look for a method which maps a <code>Date</code> object into a String, find it on the <code>DateMapper</code> class and generate an invocation of <code>asString()</code> for mapping the <code>manufacturingDate</code> attribute.</p>
              
              <p>Generated mappers retrieve referenced mappers using the component model configured for them. If e.g. CDI was used as component model for <code>CarMapper</code>, <code>DateMapper</code> would have to be a CDI bean as well. When using the default component model, any hand-written mapper classes to be referenced by MapStruct generated mappers must declare a public no-args constructor in order to be instantiable.</p>
            </div>
          </div>
          <div class="row">
            <div class="span9">
              <h3 id="section-06">6. Mapping collections</h3>
              <p>The mapping of collection types (<code>List</code>, <code>Set</code> etc.) is done in the same way as mapping bean types, i.e. by defining mapping methods with the required source and target types in a mapper interface. MapStruct supports a wide range of iterable types from the <a href="http://docs.oracle.com/javase/tutorial/collections/intro/index.html">Java Collection Framework</a>.</p>
              
              <p>The generated code will contain a loop which iterates over the source collection, converts each element and puts it into the target collection. If a mapping method for the collection element types is found in the given mapper or the mapper it uses, this method is invoked to perform the element conversion. Alternatively, if an implicit conversion for the source and target element types exists, this conversion routine will be invoked. The following shows an example:</p>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface CarMapper {&#x000A;&#x000A;    Set&lt;String&gt; integerSetToStringSet(Set&lt;Integer&gt; integers);&#x000A;&#x000A;    List&lt;CarDto&gt; carsToCarDtos(List&lt;Car&gt; cars);&#x000A;&#x000A;    CarDto carToCarDto(Car car);&#x000A;}</pre>
              <p>The generated implementation of the <code>integerSetToStringSet</code> performs the conversion from <code>Integer</code> to <code>String</code> for each element, while the generated <code>carsToCarDtos()</code> method invokes the <code>carToCarDto()</code> method for each contained element as shown in the following:</p>
              <pre class="prettyprint lang-java linenums">//GENERATED CODE&#x000A;@Override&#x000A;public Set&lt;String&gt; integerSetToStringSet(Set&lt;Integer&gt; integers) {&#x000A;    if ( integers == null ) {&#x000A;        return null;&#x000A;    }&#x000A;&#x000A;    Set&lt;String&gt; set = new HashSet&lt;String&gt;();&#x000A;&#x000A;    for ( Integer integer : integers ) {&#x000A;        set.add( String.valueOf( integer ) );&#x000A;    }&#x000A;&#x000A;    return set;&#x000A;}&#x000A;&#x000A;@Override&#x000A;public List&lt;CarDto&gt; carsToCarDtos(List&lt;Car&gt; cars) {&#x000A;    if ( cars == null ) {&#x000A;        return null;&#x000A;    }&#x000A;&#x000A;    List&lt;CarDto&gt; list = new ArrayList&lt;CarDto&gt;();&#x000A;&#x000A;    for ( Car car : cars ) {&#x000A;        list.add( carToCarDto( car ) );&#x000A;    }&#x000A;&#x000A;    return list;&#x000A;}</pre>
              <p>Note that MapStruct will look for a collection mapping method with matching parameter and return type, when mapping a collection-typed attribute of a bean, e.g. from <code>Car#passengers</code> (of type <code>List&lt;Person&gt;</code>) to <code>CarDto#passengers</code> (of type <code>List&lt;PersonDto&gt;</code>).</p>
              <div class="alert alert-warn">
                <p><strong>Note!</strong> It is not allowed to declare mapping methods with an iterable source and a non-iterable target or the other way around. An error will be raised when detecting this situation.</p>
              </div>
              <p>Also map-based mapping methods are supported. The following shows an example:</p>
              <pre class="prettyprint lang-java linenums">public interface SourceTargetMapper {&#x000A;&#x000A;    @MapMapping(valueDateFormat = &quot;dd.MM.yyyy&quot;)&#x000A;    Map&lt;String, String&gt; longDateMapToStringStringMap(Map&lt;Long, Date&gt; source);&#x000A;}</pre>
              <p>Similar to iterable mappings, the generated code will iterate through the source map, convert each value and key (either by means of an implicit conversion or by invoking another mapping method) and put them into the target map:</p>
              <pre class="prettyprint lang-java linenums">//GENERATED CODE&#x000A;@Override&#x000A;public Map&lt;Long, Date&gt; stringStringMapToLongDateMap(Map&lt;String, String&gt; source) {&#x000A;    if ( source == null ) {&#x000A;        return null;&#x000A;    }&#x000A;&#x000A;    Map&lt;Long, Date&gt; map = new HashMap&lt;Long, Date&gt;();&#x000A;&#x000A;    for ( Map.Entry&lt;String, String&gt; entry : source.entrySet() ) {&#x000A;&#x000A;        Long key = Long.parseLong( entry.getKey() );&#x000A;        Date value;&#x000A;        try {&#x000A;            value = new SimpleDateFormat( &quot;dd.MM.yyyy&quot; ).parse( entry.getValue() );&#x000A;        }&#x000A;        catch( ParseException e ) {&#x000A;            throw new RuntimeException( e );&#x000A;        }&#x000A;&#x000A;        map.put( key, value );&#x000A;    }&#x000A;&#x000A;    return map;&#x000A;}</pre>
              <p>When an iterable or map mapping method declares an interface type as return type, one of its implementation types will be instantiated in the generated code. The following table shows the supported interface types and their corresponding implementation types as instantiated in the generated code:</p>
              <table class="table">
                <thead>
                  <tr>
                    <th>Interface type</th>
                    <th>Implementation type</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <p><code>Iterable</code></p>
                    </td>
                    <td>
                      <p><code>ArrayList</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>Collection</code></p>
                    </td>
                    <td>
                      <p><code>ArrayList</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>List</code></p>
                    </td>
                    <td>
                      <p><code>ArrayList</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>Set</code></p>
                    </td>
                    <td>
                      <p><code>HashSet</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>SortedSet</code></p>
                    </td>
                    <td>
                      <p><code>TreeSet</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>NavigableSet</code></p>
                    </td>
                    <td>
                      <p><code>TreeSet</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>Map</code></p>
                    </td>
                    <td>
                      <p><code>HashMap</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>SortedMap</code></p>
                    </td>
                    <td>
                      <p><code>TreeMap</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>NavigableMap</code></p>
                    </td>
                    <td>
                      <p><code>TreeMap</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>ConcurrentMap</code></p>
                    </td>
                    <td>
                      <p><code>ConcurrentHashMap</code></p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <p><code>ConcurrentNavigableMap</code></p>
                    </td>
                    <td>
                      <p><code>ConcurrentSkipListMap</code></p>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="row">
            <div class="span9">
              <h3 id="section-07">7. Reverse mappings</h3>
              <p>In some cases bi-directional mappings are required, e.g. from entity to DTO and from DTO to entity. For this purpose, simply declare a method with the required parameter and return type on the mapping interface which also declares the forward mapping method:</p>
              <pre class="prettyprint lang-java linenums">@Mapper&#x000A;public interface CarMapper {&#x000A;&#x000A;    @Mapping(source = &quot;numberOfSeats&quot;, target = &quot;seatCount&quot;)&#x000A;    CarDto carToCarDto(Car car);&#x000A;&#x000A;    Car carDtoToCar(CarDto carDto);&#x000A;}</pre>
              <p>Here the <code>carDtoToCar()</code> method is the reverse mapping method for <code>carToCarDto()</code>. Note that any attribute mappings only have to be specified at one of the two methods and will be applied to the corresponding reverse mapping method as well.</p>
            </div>
          </div>
        </div>
        <div class="span3">
          <div data-offset-top="0" data-spy="affix" id="toc">
            <h5>Contents</h5>
            <ol class="nav nav-list">
              <li class="active">
                <a href="#section-01">Introduction</a>
              </li>
              <li>
                <a href="#section-02">Set up</a>
              </li>
              <li>
                <a href="#section-03">Defining a mapper</a>
              </li>
              <li>
                <a href="#section-04">Retrieving a mapper</a>
              </li>
              <li>
                <a href="#section-05">Data type conversions</a>
              </li>
              <li>
                <a href="#section-06">Mapping collections</a>
              </li>
              <li>
                <a href="#section-07">Reverse mappings</a>
              </li>
            </ol>
          </div>
          <script>
            (function(jQuery){
              jQuery( document ).ready( function() {
                $(document.body).scrollspy({
                  target: "#toc"
                });
              });
            }(jQuery))
          </script>
        </div>
      </div>
      <hr>
      <footer>
        <p>&copy; Gunnar Morling 2014</p>
      </footer>
    </div>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount','UA-41136939-1']);
    _gaq.push(['_gat._anonymizeIp']);
    _gaq.push(['_trackPageview']);
    (function() {
     var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
     ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
  </body>
</html>
